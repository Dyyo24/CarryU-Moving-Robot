/* TSL2591 Digital Light Sensor */
/* Dynamic Range: 600M:1 */
/* Maximum Lux: 88K */

/****IR navigation module  ****/
/***************************/

#include <Wire.h>
#include <Adafruit_Sensor.h>
#include "Adafruit_TSL2591.h"

// Example for demonstrating the TSL2591 library - public domain!

// connect SCL to analog 5
// connect SDA to analog 4
// connect Vin to 3.3-5V DC
// connect GROUND to common ground





Adafruit_TSL2591 One_tsl = Adafruit_TSL2591(2591); // pass in a number for the sensor identifier (for your use later)
Adafruit_TSL2591 Two_tsl = Adafruit_TSL2591(2592); // second sensor


#define S1 6
#define S2 5
#define Triq1 3
#define Echo1 4
double distance1;
double IR_distance;

//电机
const int calibration_LED = 5;
const int navigation_LED = 9;

//左侧电机
const int motor1_pwm = 3;
const int motor1_dir = 2;  

//右侧电机
const int motor2_pwm = 6;
const int motor2_dir = 7;
const int motor1_enable = 4;
const int motor2_enable = 8;
const int motor_speed = 100; 


const int max_int = 5;
double IRarray1[max_int];   // arrays that store the sensor readings: global variables
double ratio_array1[max_int];
double IRarray2[max_int];
double ratio_array2[max_int];
/**************************************************************************/
/*
    Displays some basic information on this sensor from the unified
    sensor API sensor_t type (see Adafruit_Sensor for more information)
*/
/**************************************************************************/
void displaySensorDetails(void)
{
  sensor_t sensor;
  One_tsl.getSensor(&sensor);
  Serial.println("------------------------------------");
  Serial.print  ("Sensor:       "); Serial.println(sensor.name);
  Serial.print  ("Driver Ver:   "); Serial.println(sensor.version);
  Serial.print  ("Unique ID:    "); Serial.println(sensor.sensor_id);
  Serial.print  ("Max Value:    "); Serial.print(sensor.max_value); Serial.println(" lux");
  Serial.print  ("Min Value:    "); Serial.print(sensor.min_value); Serial.println(" lux");
  Serial.print  ("Resolution:   "); Serial.print(sensor.resolution); Serial.println(" lux");  
  Serial.println("------------------------------------");
  Serial.println("");
  delay(500);
}

/**************************************************************************/
/*
    Configures the gain and integration time for the TSL2591
*/
/**************************************************************************/



void configureSensor(void)
{
  // You can change the gain on the fly, to adapt to brighter/dimmer light situations
  //tsl.setGain(TSL2591_GAIN_LOW);    // 1x gain (bright light)
  One_tsl.setGain(TSL2591_GAIN_MED);      // 25x gain
  Two_tsl.setGain(TSL2591_GAIN_MED);
  //tsl.setGain(TSL2591_GAIN_HIGH);   // 428x gain
  
  // Changing the integration time gives you a longer time over which to sense light
  // longer timelines are slower, but are good in very low light situtations!
  //tsl.setTiming(TSL2591_INTEGRATIONTIME_100MS);  // shortest integration time (bright light)
  //tsl.setTiming(TSL2591_INTEGRATIONTIME_200MS);
  //tsl.setTiming(TSL2591_INTEGRATIONTIME_300MS);
  One_tsl.setTiming(TSL2591_INTEGRATIONTIME_400MS);
  Two_tsl.setTiming(TSL2591_INTEGRATIONTIME_400MS);
  
  //tsl.setTiming(TSL2591_INTEGRATIONTIME_500MS);
  //tsl.setTiming(TSL2591_INTEGRATIONTIME_600MS);  // longest integration time (dim light)

  /* Display the gain and integration time for reference sake */  
  Serial.println("------------------------------------");
  Serial.print  ("Gain:         ");
  tsl2591Gain_t gain = One_tsl.getGain();
  switch(gain)
  {
    case TSL2591_GAIN_LOW:
      Serial.println("One Tsl 1x (Low)");
      break;
    case TSL2591_GAIN_MED:
      Serial.println("One Tsl 25x (Medium)");
      break;
    case TSL2591_GAIN_HIGH:
      Serial.println("One tsl 428x (High)");
      break;
    case TSL2591_GAIN_MAX:
      Serial.println("One tsl 9876x (Max)");
      break;
  }
  Serial.print  ("Timing:       ");
  Serial.print((One_tsl.getTiming() + 1) * 100, DEC); 
  Serial.println(" ms");
  Serial.println("------------------------------------");
  Serial.println("");
}


//    Performs a read using the Adafruit Unified Sensor API.
//**************************************************************************/

void unifiedSensorAPIRead(void)
{
  /* Get a new sensor event */ 
  sensors_event_t event;
  One_tsl.getEvent(&event);
 
  /* Display the results (light is measured in lux) */
  Serial.print("[ "); Serial.print(event.timestamp); Serial.print(" ms ] ");
  if ((event.light == 0) |
      (event.light > 4294966000.0) | 
      (event.light <-4294966000.0))
  {
    /* If event.light = 0 lux the sensor is probably saturated */
    /* and no reliable data could be generated! */
    /* if event.light is +/- 4294967040 there was a float over/underflow */
    Serial.println("Invalid data (adjust gain or timing)");
  }
  else
  {
    Serial.print(event.light); Serial.println(" lux");
  }
}

//***************************************************
//************Mechatronic Part*********************//
//*************************************************
void turnleft(int M_speed) //TODO
{
  digitalWrite(navigation_LED,HIGH);
  digitalWrite(motor1_dir,LOW);
  digitalWrite(motor2_dir, HIGH);
  analogWrite(motor1_pwm,M_speed);
  analogWrite(motor2_pwm,M_speed);
  digitalWrite(navigation_LED,LOW);
}



void forward(int M_speed)
{  
  digitalWrite(calibration_LED,HIGH);
  digitalWrite(motor1_dir, HIGH);
  digitalWrite(motor2_dir, HIGH);
  analogWrite(motor1_pwm,M_speed);
  analogWrite(motor2_pwm,M_speed);
  digitalWrite(calibration_LED,LOW);
  }

void brake()
{
  digitalWrite(calibration_LED,LOW);
  digitalWrite(motor1_dir, HIGH);
  digitalWrite(motor2_dir, HIGH);
  analogWrite(motor1_pwm,0);
  analogWrite(motor2_pwm,0);
}

void rotate_adjust(double *IR1, double *ratio_array1,double *IR2, double *ratio_array2){
    forward(10);
    turnleft(10);
    brake(); 
}
  
//*************************************************
//************ Signal Fusion *********************  //

double fuseIR(double *IR1, double *IR2, int n)
{
  double r;
  for (int i = 0;i<n;i++){
    r += IR1[i] + IR2[i];
  }
  return r/n;  
}

double fuse_dist(double distance1, double IR_distance)
{ //TODO  
  return distance1;
}


//*******************************************************
//************ Distance Conversion *********************  //

double IR_intensitydist(double fuse)
{
  double IR_sum = fuse;
  double dist = 0;   // TODO: determine a way to calculate this dist value
  return dist;
}
  


void MY_DISTANCE()  // calculate the distance
{  digitalWrite(Triq1,LOW);
  delayMicroseconds(2);
  digitalWrite(Triq1,HIGH);
  delayMicroseconds(10);
  distance1=pulseIn(Echo1,HIGH);
  distance1=distance1*0.018;
}


//*********************************************************
//*********************Helper Functions********************
//********************************************************

double abs_average(double *arr){
  int num = sizeof(arr)/sizeof(arr[0]);
  int sum = 0;
  for (int i = 0;i<num;i++){
    sum += arr[i];
  }
  Serial.print("Average: ");
  Serial.print(sum/num);
  
  return sum/num;
}

bool areEqual(double arr1[], double arr2[], int n) 
{  
    // Linearly compare elements 
    for (int i=0; i<n; i++) 
         if (arr1[i] != arr2[i]) 
            return false; 
    // If all elements were same. 
    return true; 
} 

//************************************************************
//************ Sensor Raw Data Processing *********************  //
//************************************************************//


int detectIR(double *IR,double *ratio) // TODO: refine rule for determining IR beacon signal
{   
    //input IR and ratio array, detect blinking condition. Return boolean for identifying the blinking beacon.
    const int max_int = 5;
    double signsIR[max_int-1];
    double changeIR[max_int-1];
    double signsratio[max_int-1];
    double change_ratio[max_int-1];

    for (int i=0; i < max_int - 1; i++){
      changeIR[i] = IR[i+1] - IR[i];
      signsIR[i] = changeIR[i]/abs(IR[i+1] - IR[i]);
      change_ratio[i] = ratio[i+1] - ratio[i];
      signsratio[i] = change_ratio[i]/abs(ratio[i+1] - ratio[i]);
    }

    double sign_poss1[4] = {1,-1,1,-1};
    double sign_poss2[4] = {-1,1,-1,1};
    
    if ((areEqual(signsIR,sign_poss1,max_int-1) || areEqual(signsIR,sign_poss2,max_int-1)) && ( abs_average(changeIR) > 100) && abs_average(change_ratio) > 0.15)  // TODO: criteria design
    {    
       return 1;}
    else{
       return 0;
      }
}


void read_data(){   // read an array of data from each sensor, and study the pattern 
  unsigned long time_start;
  unsigned long time_end;
  int intervals = 0;

  int time_step = 100;  // 100 ms per recording, last for 5
  
  const int max_int = 5;
  while (intervals < max_int){
    IRarray1[intervals] = IRread(1, One_tsl);
    ratio_array1[intervals] = IRread(2, One_tsl);
    IRarray2[intervals] = IRread(1, Two_tsl);
    ratio_array2[intervals] = IRread(2, Two_tsl);    
    
    delay(time_step); 
    intervals += 1;
  }

}

double IRread(int a, Adafruit_TSL2591 sensor)
{ //*****Reads a command 1,2,3 and the sensor object, returns a double of sensor output
  
  uint32_t lum = sensor.getFullLuminosity();
  uint16_t ir, full, visible;
  double IRFULLratio;
  ir = lum >> 16;
  full = lum & 0xFFFF;
  visible = full - ir;
  IRFULLratio = (double)ir/visible;
  
  switch (a)
  {
    case 1:  
      return ir;   // The IR intensity
      break;
    case 2:
      return IRFULLratio; // The ratio of IR/visible light
      break;

    case 3:
      return visible;  // The visible light intensity
      break;
      
  }
}


/**************************************************************************/
/*
    Main Functions
*/
/**************************************************************************/
void setup(void) 
{
  pinMode(S1,INPUT);
  pinMode(S2,INPUT);
  pinMode(Triq1,OUTPUT);
  pinMode(Echo1,INPUT);

 
  Serial.begin(9600);
  
  Serial.println("Starting TSL2591 Navigation module!");
  
  if (One_tsl.begin() && Two_tsl.begin()) 
  {
    Serial.println("Found two TSL2591 sensors");
  } 
  else 
  {
    Serial.println("Not enough sensor found ... check your wiring?");
    while (1);
  }
    
  /* Display some basic information on this sensor */
  displaySensorDetails();
  
  /* Configure the sensor */
  configureSensor();
    
  // Now we're ready to get readings ... move on to loop()!
}

void loop(void) 
{ 
  // Refer to pseudocode. Adjusts position of robot until the beacon is in the right direction within minimum distance


  // read data from sensor
  read_data();    ///
  
  double fastspeed = 10;
  double lowspeed = 2;
  double stop_car = 50;  // the distance within beacon that the robot can stop. Unit?
  
  // ensuring that the range can enter a region where at least one sensor sees something 
  
  while (~detectIR(IRarray1, ratio_array1) && ~detectIR(IRarray2, ratio_array2))
  {
    turnleft(20); // turn fast 
    read_data(); 
    // reread sensor data after turning

    delay(0);  // TODO: set delay time
    }

  // assume S1 is the left sensor, turn until S1 can see IR, but not S2
  while (detectIR(IRarray1,ratio_array1) && ~detectIR(IRarray2,ratio_array2))
  {
    turnleft(5); // turn slow
    read_data();     
  }

  while (detectIR(IRarray1,ratio_array1) && detectIR(IRarray2,ratio_array2))   
  {
    double fuse = fuseIR(IRarray1, IRarray2, max_int);
    
    IR_distance = IR_intensitydist(fuse);         // with fused IR, transform to distance calculation
    forward(20);
    while (detectIR(IRarray1,ratio_array1) && detectIR(IRarray2,ratio_array2))
    {
      rotate_adjust(IRarray1, ratio_array1, IRarray2, ratio_array2);
      read_data(); 
      } 
    
    MY_DISTANCE();
    double fused_tobeacon = fuse_dist(distance1,IR_distance);
    if (fused_tobeacon < stop_car)
    {
      Serial.print("destination !");
      break;
    }    
  }
  delay(250);
}
